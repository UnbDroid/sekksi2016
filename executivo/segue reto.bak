//MACROS
//PARAMETROS (REGULAR!!!! SEMPRE!!!!!)

//CORES
#define AZUL 2
#define VERDE 4
#define BRANCO_MIN 12
#define BRANCO_MAX 17
#define PRETO 0

//DIST
#define distMinParede 8

//LOGICA
#define direita 1
#define esquerda 2
#define tempoVirada 300


//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HTD IN_3//hitech da direita
#define HTE IN_4//hitech da esquerda

//COMUNICACAO BLUETOOTH
#define BT_CONN 1
#define INBOX 1
#define OUTBOX 5

int my_tc_d;
int my_tc_e;

// DECLARAÇÃO DE FUNÇÕES
int distanciaTachoCount(int grau);
void andaRetoDireita(int dist);
void inicializaSensores();
int distanciaGiro(int grau);
void viraEsq(int angulo);
void viraDir(int angulo);


/*
10 segundos
dir: 3468   70
esq: 3144   70

dir: 3369  70
esq: 2925  71

dir: 3402  70
esq: 3094  75

dir:
esq:
*/

void inicializaSensores()
{
  SetSensorLowspeed(USD);
  SetSensorLowspeed(USE);
  SetSensorLowspeed(HTD);
  SetSensorLowspeed(HTE);
}

void andaReto(){
        int potd, pote;

        potd = 70;
        pote = 70;

        OnFwd(MD, potd);
        OnFwd(ME, pote);
        Wait(200);
        
        if(MotorTachoCount(MD) > MotorTachoCount(ME)){
          while(MotorTachoCount(MD) > MotorTachoCount(ME))
          {
             pote+=5;
             if(pote>=90){
                          //PAU!!!
                          Off(MD);
                          Off(ME);
                          while(1){}
             }
              OnFwd(MD, potd);
              OnFwd(ME, pote);
              Wait(200);
          }

        }
        else{
           while(MotorTachoCount(MD) < MotorTachoCount(ME))
           {
             potd+=5;
             if(potd>=90){
                          //PAU!!!
                           Off(MD);
                          Off(ME);
                          while(1){}
             }
              OnFwd(MD, potd);
              OnFwd(ME, pote);
              Wait(200);
           }

        }
        
       // Off(MD);
        //Off(ME);
        NumOut(0, LCD_LINE1, MotorTachoCount(MD));
        NumOut(0, LCD_LINE2, MotorTachoCount(ME));
        NumOut(0, LCD_LINE3, potd);
        NumOut(0, LCD_LINE4, pote);
        
        OnFwd(MD, potd);
        OnFwd(ME, pote);
        Wait(10000);
        
        ClearScreen();
        NumOut(0, LCD_LINE1, MotorTachoCount(MD));
        NumOut(0, LCD_LINE2, MotorTachoCount(ME));
        NumOut(0, LCD_LINE3, potd);
        NumOut(0, LCD_LINE4, pote);
        Off(MD);
        Off(ME);
        
        while(1){}
}
     

void andaRetoDireita(int dist){ // função que faz o robô andar à "dist" centímetros da parede
	   int distanciaAtual, potd, pote;
	   my_tc_d = 0;
	   my_tc_e = 0;

	   while(distanciaTachoCount((my_tc_d + my_tc_e)/2) < (dist*100)){
	 	   distanciaAtual = SensorUS(USD);
		
		   if (distanciaAtual == dist){
			   potd = 90;
			   pote = 90;
		   }
		   else if(distanciaAtual > dist){
			   pote = 90;
			   potd = 70;
		   }
		   else if(distanciaAtual < dist){
			   pote = 70;
		   	 potd = 90;
		   }

       my_tc_d += MotorTachoCount(MD);
		   OnFwd(MD, potd);
		   my_tc_e += MotorTachoCount(ME);
	   	 OnFwd(ME, pote);

	   }

	   Off(MD);
	   Off(ME);

}

int distanciaTachoCount(int grau){
	   return (3*grau);                   //Distancia a ser percorrid/Raio da roda
}

int distanciaGiro(int grau){
	   return (((grau*172)/1420)); // COMO FOI FEITA ESSA CONVERSÃO???
}

void viraEsq(int angulo){ // função que faz o robô girar para a esquerda o ângulo recebido
     OnFwd(MD, 90);
     OnFwd(ME, -90);

     while(distanciaGiro((MotorTachoCount(MD) - MotorTachoCount(ME))/2) < angulo)
     {
      //lol
     }
     Off(MD);
     Off(ME);
}

void viraDir(int angulo){ // função que faz o robô girar para a direita o ângulo recebido
     OnFwd(MD, -90);
     OnFwd(ME, 90);

     while(distanciaGiro((- MotorTachoCount(MD) + MotorTachoCount(ME))/2) < angulo)
     {
      //lol
     }
     Off(MD);
     Off(ME);
}

task main(){
	   inicializaSensores();
	   
     andaReto();
}
