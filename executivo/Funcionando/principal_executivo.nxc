//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HTD IN_3//hitech da direita
#define HTE IN_4//hitech da esquerda

//LOGICA

#define direita 1
#define esquerda 2

//Bluetooth
	#define SIM 5
	#define SIM_US 1
	#define NAO_US 3
	#define SIM_GARRA 2
	#define NAO 0

	#define CONTINUA 6
	#define VIROU 7
	#define DESVIROU 8
	#define PARADO 0
	#define ANDANDO -2

	#define BONECO_BRANCO 4
	#define BONECO_PRETO 12
	#define BONECO_VERMELHO -1

	#define NAO_PEGA 9
	#define PEGA_OU_NAOPEGA 10
	#define PEGA 11

	//DEFINES BLUETOOTH
	#define CONECTA TRUE
	#define DESCONECTA FALSE
	//defines da conexao
	#define CONN 1
	#define INBOX 1
	#define OUTBOX 2

	//defines da struct

	#define CONSULTOR "LECA"
	#define ACAO CONECTA
	#define CONEXAO 1

//dist
	#define DIST_RE 30
	#define DIST_DA_PAREDE 8
//cores
	#define COR_VERDE 5
	#define COR_AZUL 3 // 3 ou 14, 3 eh mais certo
	#define COR_PRETA 12 //12 ou 17, 12 eh mais certo
	#define COR_NEUTRA 13//BRANCO fica acima de 13

//
#define NAO_ALIEN 0
#define SIM_ALIEN 1


//VARIAVEIS GLOBAIS
int my_tc_d = 0;
int my_tc_e = 0;
int potdGlobal = 90;
int poteGlobal = 83;




//decleração das funções
void executivo(void);

void Para();
int distanciaTachoCount(int grau);
void inicializaSensores();
void iniciaBlue();
void andaRetoDireita(int distParede, int distAndar);
void vira(int angulo, int direcao);
void DaReh();// IMPLEMENTAR

//Inicia cor do boneco
void CorDoChao(int corEsq, int corDir);
void IniciaCorDoChao(int corEsq, int corDir);
void RetornaBoneco(int cor);


//TESTAR
void ChecaParada();
void Rejeitar();
//Debug
void PrintaSensores(void);





//função principal
task main(){
	executivo();
}

//assinatura das funções
void executivo(){
	inicializaSensores();
	iniciaBlue();
	IniciaCorDoChao();

	andaRetoDireita();
}

void Para(){
	Off(MD);
	Off(ME);
}

int distanciaTachoCount(int grau){
     return (3*grau);                   //Distancia a ser percorrid/Raio da roda
}

void inicializaSensores()
{
  SetSensorLowspeed(USD);
  SetSensorLowspeed(USE);
  SetSensorLowspeed(HTD);
  SetSensorLowspeed(HTE);
}

void vira(int angulo, int direcao){
     if(direcao == esquerda){
        OnFwd(MD, 90);
        OnFwd(ME, -90);

        while(distanciaGiro((MotorTachoCount(MD) - MotorTachoCount(ME))/2) < angulo)
        {
        //lol
        }
        Off(MD);
        Off(ME);

     }else if(direcao == direita){
        OnFwd(MD, -90);
        OnFwd(ME, 90);

        while(distanciaGiro((- MotorTachoCount(MD) + MotorTachoCount(ME))/2) < angulo)
        {
        //lol
        }
        Off(MD);
        Off(ME);
     }
}

void iniciaBlue(){// FUNCAO INICIA COMUNICACAO BLUETOOTH
     CommBTConnectionType DADOS_BT;
     DADOS_BT.Name = CONSULTOR;
     DADOS_BT.ConnectionSlot = CONEXAO;
     DADOS_BT.Action = ACAO;
     /*do{
        SysCommBTConnection(DADOS_BT);

        Wait(30);//30 ms eh o tempo de comunicacao minima bluetooth entre dois bricks

     }while(BluetoothStatus(CONEXAO)!= NO_ERR);
     */
     SysCommBTConnection(DADOS_BT);
     Wait(4000);
     TextOut(0, LCD_LINE2, "Conectou Bluetooth");
}

void andaRetoDireita(int distParede, int distAndar){ // função que faz o robô andar à "distParede" centímetros da parede por "distAndar" centímetros
     int distanciaAtual, potd, pote;
     my_tc_d = 0;
     my_tc_e = 0;

     while(distanciaTachoCount((my_tc_d + my_tc_e)/2) < (distAndar*100)){
       distanciaAtual = SensorUS(USD);
    
       ChecaParada();
       CorDoChao();

       if (distanciaAtual == distParede){
         potd = 90;
         pote = 90;
       }
       else if(distanciaAtual > distParede){
         pote = 90;
         potd = 70;
       }
       else if(distanciaAtual < distParede){
         pote = 70;
         potd = 90;
       }

       my_tc_d += MotorTachoCount(MD);
       OnFwd(MD, potd);
       my_tc_e += MotorTachoCount(ME);
       OnFwd(ME, pote);

     }

     Off(MD);
     Off(ME);
}

void ChecaParada(){// TESTAR
	int acao = ANDANDO;
	ReceiveRemoteNumber(INBOX, 0, acao);
	if (acao == PARADO){
		Para();
		SendRemoteNumber(CONEXAO, OUTBOX, PARADO);
		do{
			ReceiveRemoteNumber(INBOX, 0, acao);
		}while(acao == PARADO);
		if(acao == CONTINUA){
			break;
		}else{
			Rejeitar();
		}
	}else if(acao == SIM_US){
		vira(90, esquerda);
	}
}

void Rejeitar(){// TESTAR
	int passei = NAO;
	ViraUmaRoda(ANGULO_DESCARTA_ESQUERDA);// manda o motor da direita virar um angulo dado pelo tachocount
	SendRemoteNumber(CONEXAO, OUTBOX, VIROU);
	do{
		ReceiveRemoteNumber(INBOX, 0, passei);
		Wait(30);
	}while(passei != DESVIROU);
	ViraUmaRoda(-ANGULO_DESCARTA_ESQUERDA);
	SendRemoteNumber(CONEXAO, OUTBOX, DESVIROU);
}

void IniciaCorDoChao(int corEsq, int corDir){//FUNFOU BONITO
  
  corEsq = SensorHTColorNum(HTE);
  corDir = SensorHTColorNum(HTD);
  
  if((corDir == COR_VERDE) || (corEsq == COR_VERDE)){
    RetornaBoneco(COR_VERDE);
  }else if((corDir == COR_AZUL) || (corEsq == COR_AZUL)){
    RetornaBoneco(COR_AZUL);
  }
}

void CorDoChao(int corEsq, int corDir){//TESTAR SE DA RE
  
  corEsq = SensorHTColorNum(HTE);
  corDir = SensorHTColorNum(HTD);
  
  if((corDir == COR_PRETA)||(corEsq == COR_PRETA)){//AREA KIEFAS == FOOOOOGE NEGADAA
    DaReh();
  }  
}

void RetornaBoneco(int cor){//FUNFOU BONITO
    int passei;
    
    do{
      if(cor == COR_AZUL){//BONECO COR BRANCA
        SendRemoteNumber(CONEXAO, OUTBOX, BONECO_BRANCO);
        ReceiveRemoteNumber(INBOX, true, passei);
        Wait(30);
      }else if(cor == COR_VERDE){//BONECO COR PRETA
        SendRemoteNumber(CONEXAO, OUTBOX, BONECO_PRETO);
        ReceiveRemoteNumber(INBOX, true, passei);
        Wait(30);
      }
   }while(passei != SIM);
}


//funcoes de debug
void PrintaSensores(){
    ClearScreen();
    TextOut(0, LCD_LINE1, "USD: ");
    NumOut(0, LCD_LINE2, SensorUS(USD));
    TextOut(0, LCD_LINE3, "USE: ");
    NumOut(0, LCD_LINE4, SensorUS(USE));
    TextOut(0, LCD_LINE5, "HTD: ");
    NumOut(0, LCD_LINE6, SensorHTColorNum(HTD));
    TextOut(0, LCD_LINE7, "HTE: ");
    NumOut(0, LCD_LINE8, SensorHTColorNum(HTE));
    Wait(70);
}