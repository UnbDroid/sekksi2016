//regulaveis
#define POTENCIA_RETO_DIREITA 79
#define POTENCIA_RETO_ESQUERDA 90
#define TEMPO_DEPOIS_E_ANTES_DE_GIRAR 200

#define TAMANHO_DA_ARENA 184
#define DISTANCIA_ENTRE_OS_SENSORES 26

//Constantes de Controle
#define KP 1
#define KD 5
#define DIST_LIMITE 16

//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MD_ME OUT_AB// os dois motores de movimento
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HT IN_3         //direita
#define SLUZ IN_4       //esquerda

//constantes de locomoção
#define FATORSYNC 1

//LOGICA
#define DIREITA 1
#define ESQUERDA 2

//DEFINES BLUETOOTH
	#define CONECTA TRUE
	#define DESCONECTA FALSE
	#define TEMPO_CONECTAR_BT 4000
	//defines da conexao
	#define CONN 1
	#define INBOX 1
	#define OUTBOX 2
	#define OUTBOX_ANG 3

//defines da struct

	#define CONSULTOR "LECA"
	//#define CONSULTOR "NXT"
	#define ACAO CONECTA
	#define CONEXAO 1

//cor dos bonecos
#define BONECO_BRANCO 1
#define BONECO_PRETO 2
#define BONECO_VERMELHO 3

//cor do chao
#define CHAO_PRETO 14
#define CHAO_BRANCO 13
#define CHAO_VERDE 4
#define CHAO_AZUL 2

//angulos
#define ANGULOREJEITADIREITA 1520
#define ANGCORRECAOVOLTADIREITA -45
#define ANGULOREJEITAESQUERDA 1520
#define ANGCORRECAOVOLTAESQUERDA -40

//
#define DIFERENCIALDEERRODOANGULO 5

//
#define ANGULO_CAGADINHA 180

//
#define NAO_ALIEN 0
#define SIM_ALIEN 1

//códigos para comunicação BlueTooth
#define TESTE -1
#define PARAR 1
#define SEGUIR 2
#define GIREI 3
#define DESGIRAR 4
#define REJEITAR 5
#define DESGIREI 6
#define CALIBRA 7
#define PEGUEI 8
#define CHEIO 9
#define STOP 10
#define START 11
#define VIRA 12
#define COMECEAGIRAR 13
#define PAREDEGIRAR 14

//CONSTANTES PID
#define TENDE_DIRESQ 0// de -100(vira pra direita) a 100(vira pra esquerda)
#define P_FRENTE 3
#define I_FRENTE 5
#define D_FRENTE 3
#define P_TRAS 200
#define I_TRAS 100
#define D_TRAS 200

//contantes do mapeamento
#define NORTE 0
#define LESTE 1
#define SUL 2
#define OESTE 3

//zonas
#define CENTRAL 0
#define CAVERNA 1
#define BARREIRA 2
#define ZONA_AZUL 3
#define ZONA_VERDE 4

//HT
#define HTPRETO1 17               //para o HT, preto e branco assumem dois valores diferentes cada
#define HTPRETO2 12
#define HTBRANCO1 13
#define HTBRANCO2 14
#define HTAZUL 2
#define HTVERDE 4
//SENSOR DE LUZ
#define LUZ_PRETO_MAX 30
#define LUZ_PRETO_MIN 15
#define LUZ_BRANCO_MAX 65
#define LUZ_BRANCO_MIN 35

#define DIFERENCIALDEERRODOANGULO 5

#define PARA_FRENTE 1
#define PARA_TRAS -1



//variávei do controle
int distanciaAtualDireita, distanciaAtualEsquerda, distanciaAntigaDireita, distanciaAntigaEsquerda;

//variáveis gloabais do mapeamento
int central[5][5], barreira[5][5], caverna[5][5];
int direcao;
int caminho[25];
int contPassos;
int i_global, j_global;
int progredi_na_tabela;
int zona;


//variáveis globais
int MyTcD;
int MyTcE;
int free_to_go;
int poteGlobal;
int potdGlobal;

//funções de subistituições
void MyOnFwd(int motor, int pot);
int MyMotorTachoCount(int motor);
void MyResetTachoCount(int motor);

void vira180();
void AndaFrente();

//declaração das funções
void executivo();
void init();
void desligaBlue();
void inicializaSensores();
void iniciaBlue();

void MandaGirei();
void MandaDesGirei();
int RecebeDesgirar();
void viraEsq(int angulo);
void viraDir(int angulo);
int MediaTC();
int distanciaTachoCount(int grau);
void RegulaComUS(int distParede, int direcao);
int ReceberPareGirar();
int ReceberComeceGirar();


//função para dbug
void  bip()
{
  PlaySound(SOUND_DOWN);
}
 void nbip(int n)
 {
 	int i;

 	for(i=0; i<n; i++)
 	{
 		bip();
 	}
 }

//função principal
task main()
{
	executivo();
}


void vira180()
{
	if((i_global == 0) && (direcao == LESTE))
		viraEsq(180);
	else if((i_global == 4) && (direcao == OESTE))
		viraEsq(180);
	else if((j_global == 0) && (direcao == SUL))
		viraEsq(180);
	else if((j_global == 4) && (direcao == NORTE))
		viraEsq(180);
	else{
		viraDir(180);
	}

	//viraDir(180);
	//viraEsq(180);
}


void MyOnFwd(int motor, int pot)
{
	//bip();
	//Wait(350)
	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
	}
	//bip();
	OnFwd(motor,pot);
}

int MyMotorTachoCount(int motor)
{
	int retorno;

	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
		retorno = MyTcD;
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
		retorno = MyTcE;
	}

	MyResetTachoCount(motor);

	return (retorno);
}

void MyResetTachoCount(int motor)
{
	int pd, pe;

	pd = MotorActualSpeed(MD);
	pe = MotorActualSpeed(ME);

	do{
		ResetTachoCount(motor);
		//bip();
		//bip();
	}while((MotorTachoCount(motor)>DIFERENCIALDEERRODOANGULO) || (MotorTachoCount(motor)<-DIFERENCIALDEERRODOANGULO));
	MyOnFwd(MD,pd);
	MyOnFwd(ME,pe);

}

int MediaTC()
{
	int aux_tc_d, aux_tc_e;

	aux_tc_d = MyMotorTachoCount(MD);
	aux_tc_e = MyMotorTachoCount(ME);

	return((aux_tc_d+aux_tc_e)/2);
}

int distanciaTachoCount(int grau)
{
	return ((267*grau)/100);  //Distancia a ser percorrid/Raio da roda
}
