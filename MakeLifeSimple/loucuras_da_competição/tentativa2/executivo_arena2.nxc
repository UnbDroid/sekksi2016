//regulaveis
#define CORRECAO_ANDA_QUADRANTE 703 //num anterior 695//10^-7 metros
#define CONSTANTE_DIST_TC 10//num anterior 11

#define POTENCIA_RETO_DIREITA 83
#define POTENCIA_RETO_ESQUERDA 90
#define TEMPO_DEPOIS_E_ANTES_DE_GIRAR 200

#define TAMANHO_DA_ARENA 177
#define DISTANCIA_ENTRE_OS_SENSORES 26

//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MD_ME OUT_AB// os dois motores de movimento
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HT IN_3         //direita
#define SLUZ IN_4       //esquerda

//constantes de locomoção
#define FATORSYNC 1

//LOGICA
#define DIREITA 1
#define ESQUERDA 2

//DEFINES BLUETOOTH
	#define CONECTA TRUE
	#define DESCONECTA FALSE
	#define TEMPO_CONECTAR_BT 4000
	//defines da conexao
	#define CONN 1
	#define INBOX 1
	#define OUTBOX 2
	#define OUTBOX_ANG 3
	#define OUTBOX_CORBONECO 4

//defines da struct

	#define CONSULTOR "LECA"
	//#define CONSULTOR "NXT"
	#define ACAO CONECTA
	#define CONEXAO 1

//cor dos bonecos
#define BONECO_BRANCO 1
#define BONECO_PRETO 2
#define BONECO_VERMELHO 3


//cor do chao
#define CHAO_PRETO 14
#define CHAO_BRANCO 13
#define CHAO_VERDE 4
#define CHAO_AZUL 2

//angulos
#define ANGULOREJEITADIREITA 1520
#define ANGCORRECAOVOLTADIREITA -45
#define ANGULOREJEITAESQUERDA 1520
#define ANGCORRECAOVOLTAESQUERDA -40

//
#define DIFERENCIALDEERRODOANGULO 5

//
#define ANGULO_CAGADINHA 180

//
#define NAO_ALIEN 0
#define SIM_ALIEN 1

//códigos para comunicação BlueTooth
#define TESTE -1
#define PARAR 1
#define SEGUIR 2
#define GIREI 3
#define DESGIRAR 4
#define REJEITAR 5
#define DESGIREI 6
#define CALIBRA 7
#define PEGUEI 8
#define CHEIO 9
#define STOP 10
#define START 11
#define VIRA 12
#define COMECEAGIRAR 13
#define PAREDEGIRAR 14
#define TEMOUNAOBONECO 15
#define SIMTEM 16
#define NAOVIRGULANAOTEM 17
#define TEMBONECO 18

/*//CONSTANTES PID
#define TENDE_DIRESQ -39/100     // de -100(vira pra direita) a 100(vira pra esquerda)
#define P_FRENTE 350
#define I_FRENTE 50
#define D_FRENTE 150
#define P_TRAS 200
#define I_TRAS 100
#define D_TRAS 200
*/

//PID MAIS RETO
#define TENDE_DIRESQ 0   // de -100(vira pra direita) a 100(vira pra esquerda)
#define P_FRENTE 350
#define I_FRENTE 100       //     50
#define D_FRENTE 150      //       150



//contantes do mapeamento
#define NORTE 0
#define LESTE 1
#define SUL 2
#define OESTE 3

//zonas
#define CENTRAL 0
#define CAVERNA 1
#define BARREIRA 2
#define ZONA_AZUL 3
#define ZONA_VERDE 4

//HT
#define HTPRETO1 17               //para o HT, preto e branco assumem dois valores diferentes cada
#define HTPRETO2 17//12
#define HTBRANCOMIN 245
#define HTAZUL 2
#define HTVERDE 4
//SENSOR DE LUZ
#define LUZ_PRETO_MAX 50
#define LUZ_PRETO_MIN 15
#define LUZ_BRANCO_MAX 100
#define LUZ_BRANCO_MIN 51

#define DIFERENCIALDEERRODOANGULO 5

#define PARA_FRENTE 1
#define PARA_TRAS -1
//Variáveis do HT
int ht_colornum, ht_red, ht_green, ht_blue, ht_white;

//variáveis gloabais do mapeamento
int central[5][5], barreira[5][5], caverna[5][5];
int direcao;
int caminho[25];
int contPassos;
int i_global, j_global;
int progredi_na_tabela;
int zona;
int corDaBase;

//variáveis globais
int MyTcD;
int MyTcE;
int free_to_go;
int poteGlobal;
int potdGlobal;
int trc_refD, trc_refE;

//funções de subistituições
void MyOnFwd(int motor, int pot);
int MyMotorTachoCount(int motor);
void MyResetTachoCount(int motor);

//funções do mapeamento
void init_mapeamento();
void girarCardeal(int dir);//gira para a direção desejada
void AndaNaTabela();
int tabelaPP();
void CalculaVolta();
int NumeroOndeEstou();
void vira180();
void AndaFrente();

//declaração das funções
void executivo();
void init();
void desligaBlue();
void inicializaSensores();
void iniciaBlue();
void andar();
void parar();
void rejeitar();
void rejeitarDireita();
void voltarejeitarDireita();
void rejeitarEsquerda();
void voltarejeitarEsquerda();
void MandaGirei();
void AbrirPorta();
void FecharPorta();
void MandaDesGirei();
int RecebeDesgirar();
void viraEsq(int angulo);
void viraDir(int angulo);
int MediaTC();
int distanciaTachoCount(int grau);
void MandaCalibra();
void MyOnRev(int motor, int pot);
void MyOnFwdSyncPID(int pot);
void MyOnRevSyncPID(int motores, int pot, int turnDirEsq, int p, int i, int d);
int TemQueDescartarParaAEsquerda();
void MandaStart();
void MandaStop();
//void RegulaComUS(int distParede, int direcao);
void SeguindoRota();
void SairCasa();
int idmediaTC();
sub alinha(int s);
int ReceberPareGirar();
int ReceberComeceGirar();
float GetGyroOffset();
void reset_controle();
void alinha_parede();
int velocidademedia();
int distanciaGiroDireita(int grau);
int distanciaGiroEsquerda(int grau);
int TalvezRegulaParede();
int TemBonecoNoConsultor();
void rota(int n);
int TachoCountDistancia(int dist);
void regulaTC(int dir_antiga);
void inicializaBoneco();
void decideOQueFazer();
void SairModulo();

//função para dbug
void  bip()
{
  PlaySound(SOUND_DOWN);
}
 void nbip(int n)
 {
 	int i;

 	for(i=0; i<n; i++)
 	{
 		bip();
 	}
 }

//função principal
task main()
{
	/*desligaBlue();
	iniciaBlue();
	viraDir(90);
	*/
	executivo();
}

//assinatura das funções
void executivo()
{
  int aux;
  int temp_tc_D, temp_tc_E;

	init();

	andar();//
	while(1)//void loop
	{
		ReceiveRemoteNumber(INBOX, true, aux);

		switch(aux)
		{
			case PARAR:
				parar();
			break;
			case SEGUIR:
				andar();
			break;
			case REJEITAR:
				parar();
				temp_tc_D = MyTcD;
				temp_tc_E = MyTcE;
				rejeitar();
				MyTcD = temp_tc_D;
				MyTcE = temp_tc_E;
				andar();
			break;
			case PEGUEI:
				tabelaPP();
			break;
			case CHEIO:
				caminho[contPassos] = -1;
				andar();
			break;
		}

		if(free_to_go)
		{
			andar();
		}

	}
}

void init()
{
	desligaBlue();

	init_mapeamento();
  	inicializaSensores();
  	iniciaBlue();

  	inicializaBoneco();

  	SairCasa();//comentado para testes enquanto a arena não esta pronta

  	FecharPorta();

  	MyResetTachoCount(MD);
	MyResetTachoCount(ME);
	MyTcD = 0;
	MyTcE = 0;

	poteGlobal = POTENCIA_RETO_ESQUERDA;
	potdGlobal = POTENCIA_RETO_DIREITA;

	direcao = NORTE;
	rota(2);

	MyResetTachoCount(MD);
	MyResetTachoCount(ME);
	MyTcD = 0;
	MyTcE = 0;

  	poteGlobal = POTENCIA_RETO_ESQUERDA;
	potdGlobal = POTENCIA_RETO_DIREITA;


}

void desligaBlue()
{
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = DESCONECTA;
	do{
	SysCommBTConnection(DADOS_BT);

	Wait(30);//30 ms eh o tempo de comunicacao minima bluetooth entre dois bricks

	}while(BluetoothStatus(CONEXAO)== NO_ERR);
	TextOut(0, LCD_LINE1, "Desligou Bluetooth");
}

void inicializaSensores()
{
  SetSensorLowspeed(USD);
  SetSensorLowspeed(USE);
  SetSensorLight(SLUZ);
  SetSensorLowspeed(HT);
  SetHTColor2Mode(HT, HT_CMD_COLOR2_ACTIVE);
}

void iniciaBlue()
{// FUNCAO INICIA COMUNICACAO BLUETOOTH
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = ACAO;

	SysCommBTConnection(DADOS_BT);
	Wait(TEMPO_CONECTAR_BT);
	TextOut(0, LCD_LINE2, "Conectou Bluetooth");
}

void andar()//melhorar esse função - apneas testes por enquanto
{
	free_to_go = 1;

	SeguindoRota();
}

void parar()
{
	free_to_go = 0;

	MyOnFwd(MD,0);
	MyOnFwd(ME,0);
}

void rejeitar()
{
	if(TemQueDescartarParaAEsquerda())
	{
		rejeitarEsquerda();
		Wait(200);
		MandaGirei();
		while(!RecebeDesgirar()){}
		voltarejeitarEsquerda();
	}
	else
	{
		rejeitarDireita();
		Wait(200);
		MandaGirei();
		while(!RecebeDesgirar()){}
		voltarejeitarDireita();
	}

	Wait(200);
	MandaDesGirei();
}

void rejeitarDireita()
{
	Off(MD);
	Off(ME);

	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, 90);
	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(ME,90);
	while(!ReceberPareGirar()){}
	Off(MD);
	Off(ME);

}

void voltarejeitarDireita()
{
	Off(MD);
	Off(ME);

	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, -90);
	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(ME,-90);
	while(!ReceberPareGirar()){}
	Off(MD);
	Off(ME);

}

void rejeitarEsquerda()
{
	Off(MD);
	Off(ME);

	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, -90);
	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(MD,90);
	while(!ReceberPareGirar()){}
	Off(MD);
	Off(ME);
}

void voltarejeitarEsquerda()
{
	Off(MD);
	Off(ME);

	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, 90);
	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(MD,-90);
	while(!ReceberPareGirar()){}
	Off(MD);
	Off(ME);


}

void MandaGirei()
{
	SendRemoteNumber(CONEXAO, OUTBOX, GIREI);
}

void MandaDesGirei()
{
	SendRemoteNumber(CONEXAO, OUTBOX, DESGIREI);
}


void AbrirPorta()
{
    int tc, old_tc;

   	OnFwd(MP,70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,0);
}

void FecharPorta()
{
	int tc, old_tc;

   	OnFwd(MP,-70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,-10);
}

int RecebeDesgirar()
{
	int aux;
	ReceiveRemoteNumber(INBOX, true, aux);
	if(aux == DESGIRAR)
  		return 1;
	return 0;
}

void viraEsq(int angulo){ // função que faz o robô girar para a esquerda o ângulo recebido
  Off(MD);
	Off(ME);

	angulo = -angulo;

	Wait(200);//Do not touch the waits
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, angulo);
	Wait(200);//Do not touch the waits
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(ME,-90);
 	OnFwd(MD,90);
 	while(!ReceberPareGirar()){}
 	Off(MD);
	Off(ME);
}


void viraDir(int angulo){ // função que faz o robô girar para a direita o ângulo recebido
	Off(MD);
	Off(ME);

	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX_ANG, angulo);
	Wait(200);
	SendRemoteNumber(CONEXAO, OUTBOX, VIRA);
	while(!ReceberComeceGirar()){}
	OnFwd(ME,90);
 	OnFwd(MD,-90);
 	while(!ReceberPareGirar()){}
 	Off(MD);
	Off(ME);
}

void MyOnFwd(int motor, int pot)
{
	//bip();
	//Wait(350)
	/*if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
	}*/
	//bip();
	OnFwd(motor,pot);
}

int MyMotorTachoCount(int motor)
{
	int retorno;

	if(motor == MD)
	{
		MyTcD = MotorRotationCount(motor) - trc_refD;
		retorno = MyTcD;
		/*ClearScreen();
		NumOut(0,LCD_LINE1,MotorActualSpeed(motor));
		NumOut(0,LCD_LINE2,trc_refD);
		NumOut(0,LCD_LINE3,retorno);*/

	}
	else if(motor == ME)
	{
		MyTcE = MotorRotationCount(motor) - trc_refE;
		retorno = MyTcE;
	}

	//MyResetTachoCount(motor);

	return (retorno);
}

void MyResetTachoCount(int motor)
{
	if(motor == MD)
	{
		trc_refD = MotorRotationCount(motor);
	}
	else if(motor == ME)
	{
		trc_refE = MotorRotationCount(motor);
	}
}

int MediaTC()
{
	int aux_tc_d, aux_tc_e;

	aux_tc_d = MyMotorTachoCount(MD);
	aux_tc_e = MyMotorTachoCount(ME);

	return((aux_tc_d+aux_tc_e)/2);
}

int distanciaTachoCount(int grau)
{
	return ((267*CONSTANTE_DIST_TC*grau)/1000);  //Distancia a ser percorrid/Raio da roda
}

int TachoCountDistancia(int dist)
{
	return ((1000*dist)/267*CONSTANTE_DIST_TC);  //Distancia a ser percorrid/Raio da roda
}

void MandaCalibra()
{
	SendRemoteNumber(CONEXAO, OUTBOX, CALIBRA);
}

void init_mapeamento()
{
	int i, j;

	for(i=0; i<5; i++)
	{
		for(j=0; j<5; j++)
		{
			central[i][j] = -1;
			barreira[i][j] = -1;
			caverna[i][j] = -1;
		}
	}


	for(i=0; i<25; i++)
	{
		caminho[i] = -1;
	}

	contPassos = 0;

	i_global = 0;
	j_global = 2;

	progredi_na_tabela = 0;

	zona = CENTRAL;

	direcao = LESTE;

	//teste do luan
	caminho[0] = LESTE;
	caminho[1] = NORTE;
	caminho[2] = NORTE;
	caminho[3] = NORTE;
	caminho[4] = NORTE;
	caminho[5] = OESTE;
	caminho[6] = OESTE;
	caminho[7] = OESTE;
	caminho[8] = OESTE;
	caminho[9] = -1;
	caminho[10] = -1;
	caminho[11] = -1;
	caminho[12] = -1;
	caminho[13] = -1;




	//cont
}

void girarCardeal(int dir)
{
	switch(direcao)
	{
		case NORTE:
			switch(dir)
			{
				case NORTE:
					direcao = NORTE;
				break;
				case LESTE:
					viraDir(90);
					direcao = LESTE;
				break;
				case SUL:
					vira180();
					direcao = SUL;
				break;
				case OESTE:
					viraEsq(90);
					direcao = OESTE;
				break;
			}
		break;
		case LESTE:
			switch(dir)
			{
				case NORTE:
					viraEsq(90);
					direcao = NORTE;
				break;
				case LESTE:
					direcao = LESTE;
				break;
				case SUL:
					viraDir(90);
					direcao = SUL;
				break;
				case OESTE:
					vira180();
					direcao = OESTE;
				break;
			}
		break;
		case SUL:
			switch(dir)
			{
				case NORTE:
					vira180();
					direcao = NORTE;
				break;
				case LESTE:
					viraEsq(90);
					direcao = LESTE;
				break;
				case SUL:
					direcao = SUL;
				break;
				case OESTE:
					viraDir(90);
					direcao = OESTE;
				break;
			}
		break;
		case OESTE:
			switch(dir)
			{
				case NORTE:
					viraDir(90);
					direcao = NORTE;
				break;
				case LESTE:
					vira180();
					direcao = LESTE;
				break;
				case SUL:
					viraEsq(90);
					direcao = SUL;
				break;
				case OESTE:
					direcao = OESTE;
				break;
			}
		break;
	}
	return;
}

void MyOnRev(int motor, int pot)
{
  //bip();
  //Wait(350)
  /*if(motor == MD)
  {
    MyTcD += MotorTachoCount(motor);
  }
  else if(motor == ME)
  {
    MyTcE += MotorTachoCount(motor);
  }*/
  //bip();
  OnRev(motor,pot);
  }

void MyOnFwdSyncPID(int pot){

  //MyTcD += MotorTachoCount(MD);
  //MyTcE += MotorTachoCount(ME);
  //bip();
  //OnFwdSyncPID(motores, pot, turnDirEsq, p, i ,d);
  OnFwdSyncPID(MD_ME,pot,TENDE_DIRESQ,P_FRENTE,I_FRENTE,D_FRENTE);
  //bip();
}

void MyOnRevSyncPID(int motores, int pot, int turnDirEsq, int p, int i, int d){
  //MyTcD += MotorTachoCount(MD);
  //MyTcE += MotorTachoCount(ME);
  OnRevSyncPID(MD_ME, pot, turnDirEsq, p, i ,d);
}

void AndaNaTabela()
{
	switch(direcao)
	{
		case NORTE:
			i_global++;
		break;
		case LESTE:
			j_global++;
		break;
		case SUL:
			i_global--;
		break;
		case OESTE:
			j_global--;
		break;
	}

	ClearScreen();
	NumOut(0,LCD_LINE1,i_global);
	NumOut(0,LCD_LINE2,j_global);
	//bip();
}

void tabelaPP()
{
	switch(zona)
	{
		case CENTRAL:
			central[i_global][j_global]++;
		break;
		case CAVERNA:
			caverna[i_global][j_global]++;
		break;
		case BARREIRA:
			barreira[i_global][j_global]++;
		break;
	}
}


void CalculaVolta()
{
	int i, j, k;

	k=0;

	i = i_global;
	j = j_global;

	while(!((i == 0)&&(j == 2)))
	{
		if(j==2)
		{
			caminho[k] = LESTE;
			j++;
			k++;
		}
		else if(j > 2)
		{
			if(i==0)
			{
				caminho[k] = OESTE;
				j--;
				k++;
			}
			else//i!=0
			{
				if((i==4)&&(j==3))
				{
					caminho[k] = LESTE;
					j++;
					k++;
				}
				else
				{
					caminho[k] = SUL;
					i--;
					k++;
				}
			}
		}
		else //j<2
		{
			if(i==0)
			{
				caminho[k] = LESTE;
				j++;
				k++;
			}
			else//i!=0
			{
				if((i==4)&&(j==1))
				{
					caminho[k] = OESTE;
					j--;
					k++;
				}
				else
				{
					caminho[k] = SUL;
					i--;
					k++;
				}
			}
		}
	}

	for(i=k; i<25; i++)
	{
		caminho[k] = -1;
	}

	contPassos = 0;
}

int NumeroOndeEstou()
{
	switch(zona)
	{
		case CENTRAL:
			return central[i_global][j_global];
		break;
		case CAVERNA:
			return caverna[i_global][j_global];
		break;
		case BARREIRA:
			return barreira[i_global][j_global];
		break;
	}
}

int TemQueDescartarParaAEsquerda()
{

	if((i_global == 0) && (direcao == LESTE))
		return 1;
	if((i_global == 4) && (direcao == OESTE))
		return 1;
	if((j_global == 0) && (direcao == SUL))
		return 1;
	if((j_global == 4) && (direcao == NORTE))
		return 1;

	return 0;
}
void vira180()
{
	if((i_global == 0) && (direcao == LESTE))
		viraEsq(180);
	else if((i_global == 4) && (direcao == OESTE))
		viraEsq(180);
	else if((j_global == 0) && (direcao == SUL))
		viraEsq(180);
	else if((j_global == 4) && (direcao == NORTE))
		viraEsq(180);
	else{
		viraDir(180);
	}

	//viraDir(180);
	//viraEsq(180);
}

void MandaStart()
{
	SendRemoteNumber(CONEXAO, OUTBOX, START);
}

void MandaStop()
{

	SendRemoteNumber(CONEXAO, OUTBOX, STOP);
	//nbip(7);
}

void AndaFrente()
{
	MyOnFwdSyncPID(90);
  	//OnFwdReg(MD_ME,90,OUT_REGMODE_SPEED);


	//MyOnFwd(MD, POTENCIA_RETO_DIREITA);//potdGlobal);
  	//MyOnFwd(ME, POTENCIA_RETO_ESQUERDA);//poteGlobal);
}

void SeguindoRota()
{
	int distancia_media;

	int aux_dir;

	distancia_media = distanciaTachoCount(MediaTC());

	//if(distancia_media <= ((100*TAMANHO_DA_ARENA)/5) - CORRECAO_ANDA_QUADRANTE)
	if(distancia_media <= (((100*TAMANHO_DA_ARENA)/5) - CORRECAO_ANDA_QUADRANTE))
	{
		//if((distancia_media >= (100*TAMANHO_DA_ARENA)/(5*2))&&(!progredi_na_tabela) - CORRECAO_ANDA_QUADRANTE/2)
		if((distancia_media >= (((100*TAMANHO_DA_ARENA)/(5*2)) - CORRECAO_ANDA_QUADRANTE/2) )&&(!progredi_na_tabela))
		{
			AndaNaTabela();
			progredi_na_tabela = 1;
			if(NumeroOndeEstou() == -1)
			{
				tabelaPP();
			}
		}

		if((!MotorActualSpeed(MD))&&(!MotorActualSpeed(ME)))
		{
			AndaFrente();
		}
	}
	else
	{

		aux_dir = direcao;

		decideOQueFazer();

		if(caminho[contPassos] == -1)
		{
			CalculaVolta();
		}
		nbip(contPassos);

		girarCardeal(caminho[contPassos]);

		contPassos++;
		MyResetTachoCount(MD);
		MyResetTachoCount(ME);
		MyTcD = 0;
		MyTcE = 0;

		progredi_na_tabela = 0;

		MandaStart();

		if(aux_dir != direcao)//se mudou a direção
		{
			if(!TalvezRegulaParede())
			{
				regulaTC(aux_dir);
			}

		}
	}
}

void SairCasa()
{
	int ht, luz;
	int distancia_esquerda, distancia_direita;

	AndaFrente();
	while((distanciaTachoCount(MediaTC()) <= (100*20))){}

	ReadSensorHTColor2Active(HT, ht_colornum, ht_red, ht_green, ht_blue, ht_white);
    luz=Sensor(SLUZ);
	while(!((ht_white > HTBRANCOMIN)&&((luz>LUZ_BRANCO_MIN)&&(luz<LUZ_BRANCO_MAX))))//enquanto akgum dos dois sensores for diferente de branco
	{
		ReadSensorHTColor2Active(HT, ht_colornum, ht_red, ht_green, ht_blue, ht_white);
    	luz=Sensor(SLUZ);
	}
	Wait(400);
	alinha(PARA_TRAS);

	MyResetTachoCount(MD);
	MyResetTachoCount(ME);
	MyTcD = 0;
	MyTcE = 0;

	AndaFrente();

	while((distanciaTachoCount(MediaTC()) <= (100*30))){}

	Off(MD);
	Off(ME);
}

int idmediaTC()
{
     int tc_e, tc_d, media;
     tc_e = /*My*/MotorTachoCount(ME);
     tc_d = /*My*/MotorTachoCount(MD);
     media = ((tc_d+tc_e)/2);
     return media;
}

sub alinha(int s) {
     int ht, luz;
     //ht=SensorHTColorNum(HT);
     ReadSensorHTColor2Active(HT, ht_colornum, ht_red, ht_green, ht_blue, ht_white);
     luz=Sensor(SLUZ);
     while((ht_white > HTBRANCOMIN)||((luz>LUZ_BRANCO_MIN)&&(luz<LUZ_BRANCO_MAX))) {    //Se algum dos sensores estiver lendo branco, entra na função
          if((luz>LUZ_PRETO_MIN)&&(luz<LUZ_PRETO_MAX)) {       //Se o sensor de luz (esquerda) encontrar algo preto, recua a roda esquerda para girar
               OnRev(ME, s*80);
               Wait(100);
               //while(MyMotorTachoCount(ME)<50);
               Off(MD_ME);
               //MyResetTachoCount(ME);
               //PlayTone(TONE_B7, 500);
          }
          else {
               if(ht_white < HTBRANCOMIN) {            //Se o sensor HT (direita) encontrar algo preto, recua a roda direita para girar
                    OnRev(MD, s*80);
                    Wait(100);
                    //while(MyMotorTachoCount(MD)<50);
                    Off(MD_ME);
                   // MyResetTachoCount(MD);
                    //PlayTone(TONE_A3, 500);
               }else
               {
               		OnFwd(MD_ME, s*55);                       //anda reto até que um dos dois sensores encontre algo preto
          			Wait(50); //tempo para pegar leitura do sensor/*?0/*/650*?0 */650
               }
          }
          //ht=SensorHTColorNum(HT);
          ReadSensorHTColor2Active(HT, ht_colornum, ht_red, ht_green, ht_blue, ht_white);
          luz=Sensor(SLUZ);
     }
     Off(MD_ME);
         //sai da função quando ambos os sensores estiverem lendo preto ao mesmo tempo
}


int ReceberPareGirar()
{
	int aux;
  	ReceiveRemoteNumber(INBOX, true, aux);
  	if(aux == PAREDEGIRAR)
    	return 1;
  	return 0;
}

int ReceberComeceGirar()
{
	int aux;
  	ReceiveRemoteNumber(INBOX, true, aux);
  	if(aux == COMECEAGIRAR)
    	return 1;
  	return 0;
}

int distanciaGiroDireita(int grau){
	   return (((grau*17)/170/*se girar mais diminua o denomidador*/)); // COMO FOI FEITA ESSA CONVERSÃO/*?0**/650?0**/650?0[*/650na base da tentativa e erro]
}

int distanciaGiroEsquerda(int grau){
	   return (((grau*17)/167/*se girar mais diminua o denomidador*/));
}

void alinha_parede()
{
	int tc_vlc;

	OnFwd(MD,-90);
	OnFwd(ME,-90);

	Wait(400);

	do
	{
		tc_vlc = (-1)*velocidademedia();
	}
	while(tc_vlc >= 27)

	Off(MD);
	Off(ME);
}

int velocidademedia()
{
	int tc = (MotorTachoCount(MD)+MotorTachoCount(ME))/2;
	Wait(100);
	return (((MotorTachoCount(MD)+MotorTachoCount(ME))/2-tc));
}

int TalvezRegulaParede()
{
	int cond0, cond1, cond2, cond3, cond4;

	cond0 = ((i_global==2)||(j_global==2));
	cond1 = ((i_global==4)&&(direcao==SUL));
	cond2 = ((i_global==0)&&(direcao==NORTE));
	cond3 = ((j_global==0)&&(direcao==LESTE));
	cond4 = ((j_global==4)&&(direcao==OESTE));

	if((!cond0)&&(cond1||cond2||cond3||cond4))
	{
		alinha_parede();
		return 1;
	}
	else
	{
		return 0;
	}
}

int TemBonecoNoConsultor()
{
	int aux = 0;

	Wait(400);
	SendRemoteNumber(CONEXAO, OUTBOX, TEMOUNAOBONECO);
	while((aux!=SIMTEM)&&(aux!=NAOVIRGULANAOTEM))
	{
		bip();
		ReceiveRemoteNumber(INBOX, true, aux);
	}


	//ReceiveRemoteNumer(INBOX_TEMBONECO, true, aux);
	//alteração do schiavini

	if(aux==SIMTEM)
	{
		return 1;
	}
	else
	{
		return 0;
	}

}

void rota(int n)
{
	contPassos = 0;
	progredi_na_tabela = 0;
	i_global = 0;
	j_global = 2;
	direcao = NORTE;
	MyResetTachoCount(MD);
	MyResetTachoCount(ME);
	MyTcD = 0;
	MyTcE = 0;


	switch(n)
	{
		case 1:
			girarCardeal(LESTE);
			caminho[0] = LESTE;
			caminho[1] = NORTE;
			caminho[2] = NORTE;
			caminho[3] = NORTE;
			caminho[4] = NORTE;
			caminho[5] = OESTE;
			caminho[6] = OESTE;
			caminho[7] = OESTE;
			caminho[8] = OESTE;
			caminho[9] = SUL;
			caminho[10] = SUL;
			caminho[11] = SUL;
			caminho[12] = SUL;
			caminho[13] = LESTE;
			caminho[14] = LESTE;
			caminho[15] = -1;
			caminho[16] = -1;
			caminho[17] = -1;
			caminho[18] = -1;
			caminho[19] = -1;
			caminho[20] = -1;
		break;
		case 2:
			girarCardeal(OESTE);
			caminho[0] = OESTE;
			caminho[1] = NORTE;
			caminho[2] = NORTE;
			caminho[3] = NORTE;
			caminho[4] = NORTE;
			caminho[5] = LESTE;
			caminho[6] = LESTE;
			caminho[7] = LESTE;
			caminho[8] = LESTE;
			caminho[9] = SUL;
			caminho[10] = SUL;
			caminho[11] = SUL;
			caminho[12] = SUL;
			caminho[13] = OESTE;
			caminho[14] = OESTE;
			caminho[15] = -1;
			caminho[16] = -1;
			caminho[17] = -1;
			caminho[18] = -1;
			caminho[19] = -1;
			caminho[20] = -1;
		break;
		case 3:
			girarCardeal(NORTE);
			caminho[0] = NORTE;
			caminho[1] = NORTE;
			caminho[2] = LESTE;
			caminho[3] = LESTE;
			caminho[4] = NORTE;
			caminho[5] = OESTE;
			caminho[6] = SUL;
			caminho[7] = SUL;
			caminho[8] = SUL;
			caminho[9] = SUL;
			caminho[10] = LESTE;
			caminho[11] = NORTE;
			caminho[12] = OESTE;
			caminho[13] = OESTE;
			caminho[14] = OESTE;
			caminho[15] = OESTE;
			caminho[16] = SUL;
			caminho[17] = LESTE;
			caminho[18] = NORTE;
			caminho[19] = NORTE;
			caminho[20] = NORTE;
			caminho[21] = NORTE;
			caminho[22] = OESTE;
			caminho[23] = -1;
			caminho[24] = -1;
			caminho[25] = -1;
			caminho[26] = -1;
			caminho[27] = -1;
			caminho[28] = -1;
			caminho[29] = -1;
			caminho[30] = -1;
			caminho[31] = -1;
			caminho[32] = -1;
			caminho[33] = -1;
		break;
		case 4:
			girarCardeal(NORTE);
			caminho[0] = NORTE;
			caminho[1] = NORTE;
			caminho[2] = OESTE;
			caminho[3] = OESTE;
			caminho[4] = NORTE;
			caminho[5] = LESTE;
			caminho[6] = SUL;
			caminho[7] = SUL;
			caminho[8] = SUL;
			caminho[9] = SUL;
			caminho[10] = OESTE;
			caminho[11] = NORTE;
			caminho[12] = LESTE;
			caminho[13] = LESTE;
			caminho[14] = LESTE;
			caminho[15] = LESTE;
			caminho[16] = SUL;
			caminho[17] = OESTE;
			caminho[18] = NORTE;
			caminho[19] = NORTE;
			caminho[20] = NORTE;
			caminho[21] = NORTE;
			caminho[22] = LESTE;
			caminho[23] = -1;
			caminho[24] = -1;
			caminho[25] = -1;
			caminho[26] = -1;
			caminho[27] = -1;
			caminho[28] = -1;
			caminho[29] = -1;
			caminho[30] = -1;
			caminho[31] = -1;
			caminho[32] = -1;
			caminho[33] = -1;

		break;

		/////DOIDO ISSO AQUI È SÒ PRA HOJE
		FecharPorta();
	}
}

void regulaTC(int dir_antiga)
{
	switch(dir_antiga)
	{
		case NORTE:
			switch(direcao)
			{
				case SUL:
					trc_refD += TachoCountDistancia(1800);
					trc_refE += TachoCountDistancia(1800);
				break;
				case LESTE:
					trc_refD += TachoCountDistancia(/*?00*/1000);
					trc_refE += TachoCountDistancia(/*?00*/1000);
				break;
				case OESTE:
					trc_refD += TachoCountDistancia(650);
					trc_refE += TachoCountDistancia(650);
				break;
			}
		break;
		case SUL:
			switch(direcao)
			{
				case NORTE:
					trc_refD += TachoCountDistancia(1800);
					trc_refE += TachoCountDistancia(1800);
				break;
				case LESTE:
					trc_refD += TachoCountDistancia(650);
					trc_refE += TachoCountDistancia(650);
				break;
				case OESTE:
					trc_refD += TachoCountDistancia(/*?00*/1000);
					trc_refE += TachoCountDistancia(/*?00*/1000);
				break;
			}
		break;
		case LESTE:
			switch(direcao)
			{
				case SUL:
					trc_refD += TachoCountDistancia(/*?00*/1000);
					trc_refE += TachoCountDistancia(/*?00*/1000);
				break;
				case NORTE:
					trc_refD += TachoCountDistancia(650);
					trc_refE += TachoCountDistancia(650);
				break;
				case OESTE:
					trc_refD += TachoCountDistancia(1800);
					trc_refE += TachoCountDistancia(1800);
				break;
			}
		break;
		case OESTE:
			switch(direcao)
			{
				case SUL:
					trc_refD += TachoCountDistancia(650);
					trc_refE += TachoCountDistancia(650);
				break;
				case LESTE:
					trc_refD += TachoCountDistancia(1800);
					trc_refE += TachoCountDistancia(1800);
				break;
				case NORTE:
					trc_refD += TachoCountDistancia(/*?00*/1000);
					trc_refE += TachoCountDistancia(/*?00*/1000);
				break;
			}
		break;
	}
}

void inicializaBoneco(){
	int aux;
	aux = SensorHTColorNum(HT);
	if(aux == CHAO_VERDE){
		SendRemoteNumber(CONEXAO, OUTBOX_CORBONECO, BONECO_PRETO);
	}else{
		SendRemoteNumber(CONEXAO, OUTBOX_CORBONECO, BONECO_BRANCO);
	}
	corDaBase = aux;
}

void decideOQueFazer()
{
	int arena = 2;
	int condBase = ((i_global == 0)&&(j_global == 2));
	int condCaverna1;
	int condCaverna2;

	if(arena == 2){
		condCaverna1 = (((i_global == 4)&&(j_global == 2))&&(corDaBase == CHAO_AZUL));//NORTE
		condCaverna2 = (((i_global == 2)&&(j_global == 4))&&(corDaBase == CHAO_VERDE));//LESTE
	}else{
		condCaverna1 = (((i_global == 4)&&(j_global == 2))&&(corDaBase == CHAO_VERDE));//NORTE
		condCaverna2 = (((i_global == 2)&&(j_global == 4))&&(corDaBase == CHAO_AZUL));//LESTE
	}

	switch(zona){
		case CENTRAL:
			if(condBase)//CASO FRENTE A BASE
			{
				parar();
				free_to_go = 1;
				girarCardeal(NORTE);
				//if(TemBonecoNoConsultor())
				{
						alinha(PARA_TRAS);
						OnFwd(MD, -90);
						OnFwd(ME, -90);
						while(distanciaTachoCount(MediaTC()) > -27*100) {
								 Wait(1);
						}
						Off(MD_ME);
						AbrirPorta();
						AndaFrente();
						Wait(1000);
						Off(MD_ME);

					//nbip(3);

					//chama a função devolveBoeco()
				}
				//else
				{

				}
				//chama a função que decide pra onde vai
				SairCasa();
				FecharPorta();
				direcao = NORTE;
				rota(2);
			}
			else if(condCaverna1 || condCaverna2)// PARA A ARENA 2
			{
				if(condCaverna1)
				{
					girarCardeal(NORTE);
				}else
				{
					girarCardeal(LESTE);
				}
			  SairModulo();
			  //FecharPorta();
			  zona = CAVERNA;




			  rota(2);
			}
		break;
		case CAVERNA:
			if(condBase)
			{
				girarCardeal(SUL);
				alinha(PARA_FRENTE);
				AndaFrente();
				while((distanciaTachoCount(MediaTC()) <= (100*20))){}
				girarCardeal(LESTE);
				if(corDaBase == CHAO_AZUL)
				{
					i_global = 4;
					j_global = 2;
				}
				else
				{
					i_global = 2;
					j_global = 4;
				}
				
				for(i=0; i<25; i++)
				{
					caminho[i] = -1;
				}

				contPassos = 0;
				AndaFrente();
			}
		break;
		case BARREIRA:
		break;

	}
}

void SairModulo()
{
	int ht, luz;
	int distancia_esquerda, distancia_direita;
	alinha(PARA_FRENTE);
	MyResetTachoCount(MD);
	MyResetTachoCount(ME);
	MyTcD = 0;
	MyTcE = 0;
	AndaFrente();

	while((distanciaTachoCount(MediaTC()) <= (100*30))){}

	Off(MD);
	Off(ME);
}
