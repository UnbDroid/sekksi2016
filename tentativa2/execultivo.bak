//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MD_ME OUT_AB// os dois motores de movimento
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HTD IN_3//hitech da direita
#define HTE IN_4//hitech da esquerda

//constantes de locomoção
#define FATORSYNC 1

//LOGICA
#define direita 1
#define esquerda 2

//DEFINES BLUETOOTH
	#define CONECTA TRUE
	#define DESCONECTA FALSE
	#define TEMPO_CONECTAR_BT 4000
	//defines da conexao
	#define CONN 1
	#define INBOX 1
	#define OUTBOX 2
	#define INBOX_US 3

//defines da struct

	#define CONSULTOR "LECA"
	#define ACAO CONECTA
	#define CONEXAO 1

//cor dos bonecos
#define BONECO_BRANCO 1
#define BONECO_PRETO 2
#define BONECO_VERMELHO 3

//cor do chao
#define CHAO_PRETO 14
#define CHAO_BRANCO 13
#define CHAO_VERDE 4
#define CHAO_AZUL 2

//angulos
#define ANGULOREJEITADIREITA 1500
#define ANGCORRECAOVOLTA 165

//
#define DIFERENCIALDEERRODOANGULO 5

//
#define ANGULO_CAGADINHA 180

//
#define NAO_ALIEN 0
#define SIM_ALIEN 1

//códigos para comunicação BlueTooth
#define TESTE -1
#define PARAR 1
#define SEGUIR 2
#define GIREI 3
#define DESGIRAR 4
#define REJEITAR 5
#define DESGIREI 6
#define CALIBRA 7
<<<<<<< HEAD

//contantes do mapeamento
#define DISTANCIA_QUADRANTE 39 //em centimetros
#define NORTE 0
#define LESTE 1
#define SUL 2
#define OESTE 3 

//variáveis gloabais do mapeamento
int central[5][5], barreira[5][5], caverna[5][5];
int direcao;
int caminho[25];
int contPassos;
=======
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc

//variáveis globais
int MyTcD;
int MyTcE;
int free_to_go;

//funções de subistituições
void MyOnFwd(int motor, int pot);
int MyMotorTachoCount(int motor);
void MyResetTachoCount(int motor);

//funções do mapeamento
void init_mapeamento();
void girarCardeal(int dir);//gira para a direção desejada

//declaração das funções
void executivo();
void init();
void desligaBlue();
void inicializaSensores();
void iniciaBlue();
void andar();
void parar();
void rejeitar();
void rejeitarDireita();
void voltarejeitarDireita();
void MandaGirei();
void AbrirPorta();
void FecharPorta();
void MandaDesGirei();
int RecebeUS();
int RecebeDesgirar();
void viraEsq(int angulo);
void viraDir(int angulo);
int distanciaGiroDireita(int grau);
int distanciaGiroEsquerda(int grau);
int MediaTC();
int distanciaTachoCount(int grau);
void MandaCalibra();
<<<<<<< HEAD

=======
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc

//função para dbug
void  bip()
{
  PlaySound(SOUND_DOWN);
}
 void nbip(int n)
 {
 	int i;

 	for(i=0; i<n; i++)
 	{
 		bip();
 	}
 }

//função principal
task main()
{
	executivo();
}

//assinatura das funções
void executivo()
{
  int aux, us_frente = 200, us_frente_temp;
  int temp_tc_D, temp_tc_E;

	init();

	andar();//implementar
	while(1)//void loop
	{
		us_frente_temp = RecebeUS();
		if(us_frente_temp)
			us_frente = us_frente_temp;

		ReceiveRemoteNumber(INBOX, true, aux);
		//aux=TESTE;
		switch(aux)
		{
			case PARAR:
				parar();
			break;
			case SEGUIR:
				andar();
			break;
			case REJEITAR:
				parar();
				temp_tc_D = MyTcD;
				temp_tc_E = MyTcE;
				rejeitar();
				MyTcD = temp_tc_D;
				MyTcE = temp_tc_E;
				andar();
			break;
			case TESTE:
				viraDir(180);
				AbrirPorta();
				//andar();
				for(int i=0;i<7;i++)
				{
					MyOnFwd(ME, 0);
					MyOnFwd(MD,90);
					while(MotorTachoCount(MD) < ANGULO_CAGADINHA){}
					MyOnFwd(MD, 0);
					MyOnFwd(ME,90);
					while(MotorTachoCount(ME) < ANGULO_CAGADINHA){}
				}
				parar();
				FecharPorta();


				while(1){}
			break;
		}

		if(free_to_go)
		{
			andar();
		}

	}
}

void init()
{
	desligaBlue();
<<<<<<< HEAD
	init_mapeamento();
  	inicializaSensores();
  	FecharPorta();
=======
  inicializaSensores();
  FecharPorta();
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc
	iniciaBlue();
}

void desligaBlue()
{
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = DESCONECTA;
	do{
	SysCommBTConnection(DADOS_BT);

	Wait(30);//30 ms eh o tempo de comunicacao minima bluetooth entre dois bricks

	}while(BluetoothStatus(CONEXAO)== NO_ERR);
	TextOut(0, LCD_LINE1, "Desligou Bluetooth");
}

void inicializaSensores()
{
  SetSensorLowspeed(USD);
  SetSensorLowspeed(USE);
  SetSensorLowspeed(HTD);
  SetSensorLowspeed(HTE);
}

void iniciaBlue()
{// FUNCAO INICIA COMUNICACAO BLUETOOTH
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = ACAO;

	SysCommBTConnection(DADOS_BT);
	Wait(TEMPO_CONECTAR_BT);
	TextOut(0, LCD_LINE2, "Conectou Bluetooth");
}

void andar()//melhorar esse função - apneas testes por enquanto
{
	free_to_go = 1;

<<<<<<< HEAD
	if(distanciaTachoCount(MediaTC()) <= 100*DISTANCIA_QUADRANTE)
=======
	if(distanciaTachoCount(MediaTC()) <= 10000)//um metro
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc
	{
		MyOnFwd(MD,84);
		MyOnFwd(ME,90);
		//bip();
	}
	else
	{
<<<<<<< HEAD
		//decide para onde vai, vira, zera os tcs e calibra.
		//parar sem mexer na free to go
		MyOnFwd(MD,0);
		MyOnFwd(ME,0);
		if(caminho[contPassos] == -1)
		{
			nbip(5)
			while(1){}
		}
		girarCardeal(caminho[contPassos++]);
		MyResetTachoCount(MD);
		MyResetTachoCount(ME);
		MyTcD = 0;
		MyTcE = 0;

		//teste:
		//nbip(3);
		//Wait(10000);
		/*viraEsq(90);
=======
		//nbip(3);
		//Wait(10000);
		viraEsq(90);
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc
		MandaCalibra();
		MyResetTachoCount(ME);
		MyResetTachoCount(MD);
		MyTcD = 0;
		MyTcE = 0;
	*/
	}
}

void parar()
{
	free_to_go = 0;

	MyOnFwd(MD,0);
	MyOnFwd(ME,0);
}

void rejeitar()
{
	//bip();
	//bip();
	//implementar uma função para decidir para qual lado deve girar
	rejeitarDireita();
	//bip();
	MandaGirei();
	//bip();
	while(!RecebeDesgirar()){}
	//bip();
	voltarejeitarDireita();
	//bip();
	MandaDesGirei();
	//bip();
}

void rejeitarDireita()
{
	int tc;

	//bip();
	MyOnFwd(ME,90);
	//bip();

	do{
     tc = MotorTachoCount(ME);
  	}while(tc<ANGULOREJEITADIREITA);
  	//bip();
	parar();
}

void voltarejeitarDireita()
{
	int tc;

	MyOnFwd(ME,-90);

	do {
		tc = MotorTachoCount(ME);
	} while(tc>(-ANGULOREJEITADIREITA)-ANGCORRECAOVOLTA);

	parar();
}

void MandaGirei()
{
	SendRemoteNumber(CONEXAO, OUTBOX, GIREI);
}

void MandaDesGirei()
{
	SendRemoteNumber(CONEXAO, OUTBOX, DESGIREI);
}


void AbrirPorta()
{
    int tc, old_tc;

   	OnFwd(MP,70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,0);
}

void FecharPorta()
{
	int tc, old_tc;

   	OnFwd(MP,-70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,-10);
}

int RecebeUS()
{
	int aux;

	ReceiveRemoteNumber(INBOX_US, true, aux);

	return aux;
}

int RecebeDesgirar()
{
	int aux;
  	ReceiveRemoteNumber(INBOX, true, aux);
  	if(aux == DESGIRAR)
    	return 1;
  	return 0;
}

void viraEsq(int angulo){ // função que faz o robô girar para a esquerda o ângulo recebido
     MyOnFwd(MD, 90);
     MyOnFwd(ME, -90);

     while(distanciaGiroEsquerda((MotorTachoCount(MD) - MotorTachoCount(ME))/2) < angulo)
     {
      //lol
     }
     MyOnFwd(MD,0);
     MyOnFwd(ME,0);
}


void viraDir(int angulo){ // função que faz o robô girar para a direita o ângulo recebido
     OnFwd(MD, -90);
     OnFwd(ME, 90);

     while(distanciaGiroDireita((- MotorTachoCount(MD) + MotorTachoCount(ME))/2) < angulo)
     {
      //lol
     }
     MyOnFwd(MD,0);
     MyOnFwd(ME,0);
}

int distanciaGiroDireita(int grau){
	   return (((grau*17)/149));
}

int distanciaGiroEsquerda(int grau){
<<<<<<< HEAD
	   return (((grau*17)/157));
=======
	   return (((grau*17)/155));
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc
}

void MyOnFwd(int motor, int pot)
{
	//bip();
	//Wait(350)
	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
	}
	//bip();
	OnFwd(motor,pot);
}

int MyMotorTachoCount(int motor)
{
	int retorno;

	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
		retorno = MyTcD;
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
		retorno = MyTcE;
	}

	MyResetTachoCount(motor);

	return (retorno);
}

void MyResetTachoCount(int motor)
{
	do{
		ResetTachoCount(motor);
		//bip();
		//bip();
	}while((MotorTachoCount(motor)>DIFERENCIALDEERRODOANGULO) || (MotorTachoCount(motor)<-DIFERENCIALDEERRODOANGULO));
}

int MediaTC()
{
	int aux_tc_d, aux_tc_e;

	aux_tc_d = MyMotorTachoCount(MD);
	aux_tc_e = MyMotorTachoCount(ME);

	return((aux_tc_d+aux_tc_e)/2);
}

int distanciaTachoCount(int grau)
{
	return ((267*grau)/100);  //Distancia a ser percorrid/Raio da roda
}

void MandaCalibra()
{
	SendRemoteNumber(CONEXAO, OUTBOX, CALIBRA);
<<<<<<< HEAD
}

void init_mapeamento()
{
	int i, j;

	for(i=0; i<5; i++)
	{
		for(j=0; j<5; j++)
		{
			central[i][j] = -1;
			barreira[i][j] = -1;
			caverna[i][j] = -1;
		}
	}

	contPassos = 0;

	direcao = NORTE;

	for(i=0; i<25; i++)
	{
		caminho[i] = -1;
	}

	caminho[0] = LESTE;
	caminho[1] = NORTE;
	caminho[2] = NORTE;
	caminho[3] = OESTE;
	caminho[4] = SUL;
	caminho[5] = SUL;
	//caminho[6] = 1;
	//caminho[7] = N;
	//caminho[8] = N;
}

void girarCardeal(int dir)
{
	switch(direcao)
	{
		case NORTE:
			switch(dir)
			{
				case NORTE:
					direcao = NORTE;
				break;
				case LESTE:
					viraDir(90);
					direcao = LESTE;
				break;
				case SUL:
					viraDir(180);
					direcao = SUL;
				break;
				case OESTE:
					viraEsq(90);
					direcao = OESTE;
				break;
			}
		break;
		case LESTE:
			switch(dir)
			{
				case NORTE:
					viraEsq(90);
					direcao = NORTE;
				break;
				case LESTE:
					direcao = LESTE;
				break;
				case SUL:
					viraDir(90);
					direcao = SUL;
				break;
				case OESTE:
					viraDir(180);
					direcao = OESTE;
				break;
			}
		break;
		case SUL:
			switch(dir)
			{
				case NORTE:
					viraDir(180);
					direcao = NORTE;
				break;
				case LESTE:
					viraEsq(90);
					direcao = LESTE;
				break;
				case SUL:
					direcao = SUL;
				break;
				case OESTE:
					viraDir(90);
					direcao = LESTE;
				break;
			}
		break;
		case OESTE:
			switch(dir)
			{
				case NORTE:
					viraDir(90);
					direcao = NORTE;
				break;
				case LESTE:
					viraDir(180);
					direcao = LESTE;
				break;
				case SUL:
					viraEsq(90);
					direcao = SUL;
				break;
				case OESTE:
					direcao = OESTE;
				break;
			}
		break;
	}
	return;
=======
>>>>>>> 5eca14fd8d7edc04f9317eb05d35f31cf23578dc
}
