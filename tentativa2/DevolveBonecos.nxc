

//regulaveis
#define POTENCIA_RETO_DIREITA 79
#define POTENCIA_RETO_ESQUERDA 90
#define TEMPO_DEPOIS_E_ANTES_DE_GIRAR 200

#define TAMANHO_DA_ARENA 184
#define DISTANCIA_ENTRE_OS_SENSORES 26

//Constantes de Controle
#define KP 10
#define KD 20
#define DIST_LIMITE 16

//SENSORES E MOTORES
#define MD OUT_B //motor da direita
#define ME OUT_A //motor da esquerda
#define MD_ME OUT_AB// os dois motores de movimento
#define MP OUT_C //motor da porta
#define USD IN_1 //Utrasonico da direita
#define USE IN_2 //Utrasonico da esquerda
#define HT IN_3         //direita
#define SLUZ IN_4       //esquerda

//constantes de locomoção
#define FATORSYNC 1

//LOGICA
#define DIREITA 1
#define ESQUERDA 2

//DEFINES BLUETOOTH
	#define CONECTA TRUE
	#define DESCONECTA FALSE
	#define TEMPO_CONECTAR_BT 4000
	//defines da conexao
	#define CONN 1
	#define INBOX 1
	#define OUTBOX 2
	#define OUTBOX_ANG 3

//defines da struct

	#define CONSULTOR "LECA"
	//#define CONSULTOR "NXT"
	#define ACAO CONECTA
	#define CONEXAO 1

//cor dos bonecos
#define BONECO_BRANCO 1
#define BONECO_PRETO 2
#define BONECO_VERMELHO 3

//cor do chao
#define CHAO_PRETO 14
#define CHAO_BRANCO 13
#define CHAO_VERDE 4
#define CHAO_AZUL 2

//angulos
#define ANGULOREJEITADIREITA 1520
#define ANGCORRECAOVOLTADIREITA -45
#define ANGULOREJEITAESQUERDA 1520
#define ANGCORRECAOVOLTAESQUERDA -40

//
#define DIFERENCIALDEERRODOANGULO 5

//
#define ANGULO_CAGADINHA 180

//
#define NAO_ALIEN 0
#define SIM_ALIEN 1

//códigos para comunicação BlueTooth
#define TESTE -1
#define PARAR 1
#define SEGUIR 2
#define GIREI 3
#define DESGIRAR 4
#define REJEITAR 5
#define DESGIREI 6
#define CALIBRA 7
#define PEGUEI 8
#define CHEIO 9
#define STOP 10
#define START 11
#define VIRA 12
#define COMECEAGIRAR 13
#define PAREDEGIRAR 14
#define JOGAPRADENTRO 15

//CONSTANTES PID
#define TENDE_DIRESQ 0// de -100(vira pra direita) a 100(vira pra esquerda)
#define P_FRENTE 3
#define I_FRENTE 5
#define D_FRENTE 3
#define P_TRAS 200
#define I_TRAS 100
#define D_TRAS 200

//contantes do mapeamento
#define NORTE 0
#define LESTE 1
#define SUL 2
#define OESTE 3

//zonas
#define CENTRAL 0
#define CAVERNA 1
#define BARREIRA 2
#define ZONA_AZUL 3
#define ZONA_VERDE 4

//HT
#define HTPRETO1 17               //para o HT, preto e branco assumem dois valores diferentes cada
#define HTPRETO2 12
#define HTBRANCO1 13
#define HTBRANCO2 14
#define HTAZUL 2
#define HTVERDE 4
//SENSOR DE LUZ
#define LUZ_PRETO_MAX 50
#define LUZ_PRETO_MIN 15
#define LUZ_BRANCO_MAX 65
#define LUZ_BRANCO_MIN 51

#define DIFERENCIALDEERRODOANGULO 5

#define PARA_FRENTE 1
#define PARA_TRAS -1

//variávei do controle
int distanciaAtualDireita, distanciaAtualEsquerda, distanciaAntigaDireita, distanciaAntigaEsquerda;

//variáveis gloabais do mapeamento
int central[5][5], barreira[5][5], caverna[5][5];
int direcao;
int caminho[25];
int contPassos;
int i_global, j_global;
int progredi_na_tabela;
int zona;


//variáveis globais
int MyTcD;
int MyTcE;
int free_to_go;
int poteGlobal;
int potdGlobal;


void MyOnFwd(int motor, int pot);
void andaBalancando();
void AbrirPorta();
void FecharPorta();
void MyResetTachoCount(int motor);
void init();
void inicializaSensores();
int MyMotorTachoCount(int motor);
int MediaTC();
int distanciaTachoCount(int grau);
void devolve_bonecos();
void alinha(int s);
void desligaBlue();
void iniciaBlue();


task main() {
     init();
     PlayTone(TONE_A3, 500);
     devolve_bonecos();//

     PlayTone(TONE_B7, 500);//

     while(TRUE) {
          Wait(500);
     }
}

void init(){
  inicializaSensores();
  MyResetTachoCount(MD);
  MyResetTachoCount(ME);
	desligaBlue();
	iniciaBlue();
}

void MyOnFwd(int motor, int pot)
{
	//bip();
	//Wait(350)
	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
	}
	//bip();
	OnFwd(motor,pot);
}

void andaBalancando()
{
  MyOnFwd(MD, 0);
  MyOnFwd(ME,90);
  while(MotorTachoCount(ME) < ANGULO_CAGADINHA/2){}
  for(int i=0;i<6;i++)
  {
    MyOnFwd(ME, 0);
    MyOnFwd(MD,90);
    while(MotorTachoCount(MD) < ANGULO_CAGADINHA){}
    MyOnFwd(MD, 0);
    MyOnFwd(ME,90);
    while(MotorTachoCount(ME) < ANGULO_CAGADINHA){}
  }
  MyOnFwd(ME, 0);
  MyOnFwd(MD,90);
  while(MotorTachoCount(MD) < (ANGULO_CAGADINHA)/2){}
  Off(MD_ME);
}

void AbrirPorta()
{
    int tc, old_tc;

   	OnFwd(MP,70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,0);
}

void FecharPorta()
{
	int tc, old_tc;

   	OnFwd(MP,-70);
	tc = MotorTachoCount(MP);
	do
	 {
	  Wait(200);
	  old_tc = tc;
	  tc = MotorTachoCount(MP);
	}while(tc!=old_tc);

	OnFwd(MP,-10);
}

void MyResetTachoCount(int motor)
{
	int pd, pe;

	pd = MotorActualSpeed(MD);
	pe = MotorActualSpeed(ME);

	do{
		ResetTachoCount(motor);
		//bip();
		//bip();
	}while((MotorTachoCount(motor)>DIFERENCIALDEERRODOANGULO) || (MotorTachoCount(motor)<-DIFERENCIALDEERRODOANGULO));
	MyOnFwd(MD,pd);
	MyOnFwd(ME,pe);

}

void inicializaSensores()
{
  SetSensorLowspeed(USD);
  SetSensorLowspeed(USE);
  SetSensorLight(SLUZ);
  SetSensorLowspeed(HT);
}

int MyMotorTachoCount(int motor)
{
	int retorno;

	if(motor == MD)
	{
		MyTcD += MotorTachoCount(motor);
		retorno = MyTcD;
	}
	else if(motor == ME)
	{
		MyTcE += MotorTachoCount(motor);
		retorno = MyTcE;
	}

	MyResetTachoCount(motor);

	return (retorno);
}

int MediaTC()
{
	int aux_tc_d, aux_tc_e;

	aux_tc_d = MyMotorTachoCount(MD);
	aux_tc_e = MyMotorTachoCount(ME);

	return((aux_tc_d+aux_tc_e)/2);
}

int distanciaTachoCount(int grau)
{
	return ((76*267*grau)/10000);  //Distancia a ser percorrid/Raio da roda
}


sub alinha(int s) {
     int ht, luz;
     ht=SensorHTColorNum(HT);
     luz=Sensor(SLUZ);
     while(((ht==HTBRANCO1)||(ht==HTBRANCO2))||((luz>LUZ_BRANCO_MIN)&&(luz<LUZ_BRANCO_MAX))) {    //Se algum dos sensores estiver lendo branco, entra na função
          if((luz>LUZ_PRETO_MIN)&&(luz<LUZ_PRETO_MAX)) {       //Se o sensor de luz (esquerda) encontrar algo preto, recua a roda esquerda para girar
               OnRev(ME, s*80);
               Wait(200);
               //while(MyMotorTachoCount(ME)<50);
               Off(MD_ME);
               //MyResetTachoCount(ME);
               //PlayTone(TONE_B7, 500);
          }
          else {
               if((ht==HTPRETO1)||(ht==HTPRETO2)) {            //Se o sensor HT (direita) encontrar algo preto, recua a roda direita para girar
                    OnRev(MD, s*80);
                    Wait(200);
                    //while(MyMotorTachoCount(MD)<50);
                    Off(MD_ME);
                   // MyResetTachoCount(MD);
                    //PlayTone(TONE_A3, 500);
               }
          }
          OnFwd(MD_ME, s*55);                       //anda reto até que um dos dois sensores encontre algo preto
          Wait(100);                                   //tempo para pegar leitura do sensor?!?!
          ht=SensorHTColorNum(HT);
          luz=Sensor(SLUZ);
          //printa(ht, luz);
     }
     Off(MD_ME);
         //sai da função quando ambos os sensores estiverem lendo preto ao mesmo tempo
}

sub devolve_bonecos() {
     alinha(PARA_TRAS);
     MyOnFwd(MD, -90);
     MyOnFwd(ME, -90);
     Wait(1);
     while(distanciaTachoCount(MediaTC()) > -27*100) {
          Wait(1);
     }
     Off(MD_ME);
     AbrirPorta();
     andaBalancando();
     FecharPorta();
     alinha(PARA_TRAS);
     SendRemoteNumber(CONEXAO, OUTBOX, JOGAPRADENTRO);
     MyOnFwd(MD, -90);
     MyOnFwd(ME, -90);
     Wait(1);
     while(distanciaTachoCount(MediaTC()) > -20*100){
          Wait(1);
     }
     Off(MD_ME);
     AbrirPorta();
     andaBalancando();
     FecharPorta();
     alinha(PARA_TRAS);
     MyOnFwd(MD, 90);
     MyOnFwd(ME, 90);
     Wait(1);
     while(distanciaTachoCount(MediaTC()) < 20*100) {
          Wait(1);
     }
     Off(MD_ME);
}


void iniciaBlue()
{// FUNCAO INICIA COMUNICACAO BLUETOOTH
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = ACAO;

	SysCommBTConnection(DADOS_BT);
	Wait(TEMPO_CONECTAR_BT);
	TextOut(0, LCD_LINE2, "Conectou Bluetooth");
}


void desligaBlue()
{
	CommBTConnectionType DADOS_BT;
	DADOS_BT.Name = CONSULTOR;
	DADOS_BT.ConnectionSlot = CONEXAO;
	DADOS_BT.Action = DESCONECTA;
	do{
	SysCommBTConnection(DADOS_BT);

	Wait(30);//30 ms eh o tempo de comunicacao minima bluetooth entre dois bricks

	}while(BluetoothStatus(CONEXAO)== NO_ERR);
	TextOut(0, LCD_LINE1, "Desligou Bluetooth");
}
